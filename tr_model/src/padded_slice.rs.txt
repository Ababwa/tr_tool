use std::{
	alloc::{alloc, dealloc, handle_alloc_error, Layout}, mem::{align_of, size_of, MaybeUninit},
	ops::{Deref, DerefMut}, ptr, slice,
};

const UNIT: usize = 16;

/// Owned slice contained in a buffer padded to a multiple of 16.
pub struct PaddedSlice<T> {
	ptr: *mut T,
	len: usize,
	size: usize,
}

impl<T> PaddedSlice<T> {
	pub fn uninit(len: usize) -> PaddedSlice<MaybeUninit<T>> {
		let size = ((len * size_of::<T>() + UNIT - 1) / UNIT) * UNIT;
		let layout = Layout::from_size_align(size, align_of::<T>()).unwrap();
		let ptr = unsafe { alloc(layout) };
		if ptr.is_null() {
			handle_alloc_error(layout);
		}
		for offset in len * size_of::<T>()..size {
			unsafe { ptr.add(offset).write(0); }//zero padding
		}
		PaddedSlice { ptr: ptr.cast(), len, size }
	}
	
	pub fn bytes(&self) -> &[u8] {
		unsafe { slice::from_raw_parts(self.ptr.cast(), self.size) }
	}
}

impl<T> PaddedSlice<MaybeUninit<T>> {
	pub unsafe fn assume_init(self) -> PaddedSlice<T> {
		PaddedSlice { ptr: self.ptr.cast(), len: self.len, size: self.size }
	}
}

impl<T> Deref for PaddedSlice<T> {
	type Target = [T];
	
	fn deref(&self) -> &Self::Target {
		unsafe { slice::from_raw_parts(self.ptr, self.len) }
	}
}

impl<T> DerefMut for PaddedSlice<T> {
	fn deref_mut(&mut self) -> &mut Self::Target {
		unsafe { slice::from_raw_parts_mut(self.ptr, self.len) }
	}
}

impl<T> Drop for PaddedSlice<T> {
	fn drop(&mut self) {
		unsafe {
			ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.ptr, self.len));
			let layout = Layout::from_size_align_unchecked(self.size, align_of::<T>());//already allocated
			dealloc(self.ptr.cast(), layout);
		}
	}
}
